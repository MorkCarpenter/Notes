# 指针
指针指向变量的地址，在 go 中指针的声明方式如下:
```go
var p *T
```
*T 是 T 类型的指针。零值为 nil。
通常的初始化方式像这样:
```go
a := 1
var p *int = &a
```
或者也可以不写var关键字和类型，如下:
```go
a := 1
p = &a
```
不过 &a 中的 & 这个符号是必须的，它是取地址的意思，在这里的意思的返回变量 a 的地址。

与 & 相对就是 * 操作符，它的作用是引用地址代表的值。如下:
```go
i := 49
p = &i
fmt.Printfln(*p)
```
此时，将会打印 49 

指针同样可以用来改变其所指向的变量值。如下:
```go
*p = 1
```
这样， i 就被我们修改为了 1 

# 结构体
go 中的结构体是一组变量的集合，是一组字段，声明方式如下:
```go
type 结构体名 struct{
    变量名 T
    变量名 T
    ...
}
```
对于结构体中的字段，也就是其中一个个的变量，我们可以用```.```来进行访问，如下:
```go
type TextStruct{
    X int
    Y int
}

...
v := TextStruct{1 , 2}
v.X = 114
v.Y = 514
```
这样，其中的 X 和 Y 的值就被修改了

当然了，与其他语言类似， go 中的结构体也同样拥有指针，不过不同的是，即使是结构体指针，访问其中的变量也只需要通过```.```而不是```->```，如下:
```go
type TextStruct{
    X int
    Y int
}
...
v := TextStruct{1 , 2}
p = &v
(*p).X = 114
(*p).Y = 514
```
不过 go 为了方便写代码，允许隐式(不写 * )间接引用(通过指针使用和修改变量)，如下:
```go
p.X = 114
p.Y = 514
```
结构体的创建的一些技巧:
- 可以通过```Name:```语法来仅初始化部分变量
- 可以在初始化时初始化为结构体指针
```go
type TextStruct{
    X int
    Y int
}

v := TextStruct{X:114}//Y不写就会赋值为 0
p = &TextStruct{}//创建指针，X Y都没写，所以都是 0 
```

# 数组与切片
go 中的数组默认是固定长度的,并且声明方式也有一点不同,如下:
```go
var ary [10]int
```
这样就创建了一个长度为10的int型数组

但是固定长度的数组在大部分情况下并不会非常好用。所以 go 提供了切片，如下:
```go
var ary []T
```
切片的声明与数组十分相似。

切片也同样可以通过数组来得到，这也是它被称为切片的原因，如下:
```go
var s = a[1:4]
```
此时， s 是一个包含 a 中第一个到第三个个元素的切片。切片选的是前闭后开区间中的元素，这也是为什么代码中明明右边写的是 4 ，但是第四个元素却没有被包括的原因。

要注意的是，与其他语言一样，数组和切片的元素是从第零个元素开始的，所以实际上 s 切片并没有包括 a[0]

当多个切片指向同一段数组，我们修改其中一个切片里面的元素，其他切片会跟着修改吗？

答案是会的，切片有点像指向数组的指针。不过要注意的是，只是像，但不是同一个东西。

```go
ary := [3]int{1,2,3}

a := ary[0:2]
b := ary[0:2]

a[0] = 114
```
这段代码之后， b[0] 也同样会变为114。
## 默认行为与零值
切片的默认值:

```go
a[0:10]
a[:10]
a[0:]
a[:]
```
以上几个切片方式的结果是一样的，也就是当不指定值时，默认为从 0 开始，一直到数组结尾。

在 go 中，切片本身是有长度和容量的。

切片的零值是```nil```。
```go
var s []int
```
这个时候 s 的值就是 nil 。

## make()
切片也同样可以通过```make()```函数创建，如下:
```go
make([]T,长度,容量)
```
比如创建一个 0 长度， 10 容量的int切片:
```go
make([]int,0,10)
```
容量也可以不用写:
```go
make([]int,10)
```
## append()
切片在长度没有到达容量时，可以通过```append()```来追加新的元素

比如我现在有一个 []int 切片 s
```go
s = append(s, 1, 2)
```
这样，s被追加了两个元素。

当通过这个函数追加的元素超过了容量，append将会创建新的数组，并将这个切片指向新的数组。
# for-range 语句
通过 range 形式的 for 循环，我们可以更加高效的遍历切片，如下:
```go
for i, v := range s {

}
```
此时， i 代表着正在遍历的元素的下标，也就是它是第几个元素， v 则是正在遍历的元素的复制。

当然你也可以通过```_```忽略两个中的一个，如下:
```go
for _, v := range s {//忽略下标

}
for i, _ := range s {//忽略值

}
for i := range s {//忽略值

}
```

