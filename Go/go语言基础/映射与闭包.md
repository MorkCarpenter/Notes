# 映射
go 中也与其他语言一样存在映射，这是一种相比于数组更特别的储存形式。在映射中，每个被储存的值都有一个键对应，你可以通过键去寻找到那个值。如下:
```go
var m = map[string]int{
    "sign" : 114,
    "name" : 514,
}
```
这样，我们可以通过 sign 字符串找到 114 这个整数， name 字符串找到 514 这个整数。比数组使用场景更多。实际上，你也可以去了解**哈希映射**这个知识点来自己造一个类似功能的结构体，有助于你理解这个功能。不过没有必要去学习现在的大多数语言的 map 是如何实现的，这将非常复杂。

go 中也可以通过make的方式创建映射:
```go
var m map[string]int//此时m = nil
m = make(map[string]int)
```
创建后可以通过如下方式增加修改元素:
```go
m["name"] = 9527
```
获取元素的两种方式:
```go
elem = m["name"]
elem , ok = m["name"]
```
上面代码中， ok 是可以省略的，它是用来检测是否存在此映射，如果不存在， ok 将会是 false ，而 elem 则会被赋值为零值。推荐你加上 ok ，在执行过程中确定获得的变量是存在的是一个好习惯。

映射也可以删除某个元素， 通过 delete 函数可以删除:
```go
delete(m, "name")
```
这样，```m["name"]``` 就被删除了

# 函数值与闭包
go 中可以将函数用作另外一个函数的变量或者返回值，被使用的函数就是函数值。就像这样:
```go
func Cmp(fn func(float64, float64) float64) float64{
    return fn(3.0, 4.0)
}
```
该试例函数要求传入一个函数值，该函数值的要求是需要有两个 float64 变量，并且返回一个 float64 。

## 闭包
闭包是一种特殊的函数值，它相当于一个函数加许多个变量组合起来的结构体，可以用来实现函数式编程。试例如下:
```go
func adder() func(int) int {
    sum := 0
    return func(x int) int{
        sum += x
        return sum
    }
}

pos := adder()
for i := 0; i < 10 ; i++ {
    fmt.Println(pos(i))
}
```
此时的 pos 就算一个闭包，它在其函数体内调用了不在函数体内的 sum 变量，所以 go 就会创建一个闭包， 该闭包中就包含了一个初始值为 0 的 sum 。

