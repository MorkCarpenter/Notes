# 单源最短路

## 都是正数的边路
### Dij
>O(N^2)
### 堆优化
>O(N*M)
## 负环

### Frod
>O(N*M)

思路，循环n次，每次遍历所有边，更新最短距离。示例代码：
```cpp
    for n次
        for 边(从a指向b,距离为w)
            dist[b] = min(dist[b],last_dist[a]+w);
```
只能用frod算法的情况：最多用k条边的最短路

注意更新距离时要考虑要不要上一次更新的结果，也就是示例代码中的```last_dist```；
### SPFA
 SPFA 是对 Frod 算法的一个优化，在写 Frod 时，显然可以发现，在遍历时，只有 last_dist[a]+w 比原来变小的时候才会更新。
 所以我们可以写一个队列，里面存放了所有比原来变小的点，然后进行更新。
# 多源最短路

## 弗洛伊德